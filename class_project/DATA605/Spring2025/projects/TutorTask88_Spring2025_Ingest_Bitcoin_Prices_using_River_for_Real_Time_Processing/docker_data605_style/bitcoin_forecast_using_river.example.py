#!/usr/bin/env python
# coding: utf-8

# # Ingest Bitcoin Prices using River for Real-Time Processing
# 
# This notebook demonstrates how to ingest real-time Bitcoin price data using the CoinGecko API and perform online learning using the River library.
# 
# **Goals:**
# - Stream live Bitcoin price data
# - Use River for incremental training
# - Maintain a rolling window of prices
# - Extract lag features for prediction
# - Visualize real-time predictions and model accuracy
# 

# In[3]:


get_ipython().run_line_magic('load_ext', 'autoreload')
get_ipython().run_line_magic('autoreload', '2')
get_ipython().run_line_magic('matplotlib', 'inline')


# ## Imports
# This cell initializes the required packages and imports the helper functions from bitcoin_forecast_utils.py.

# In[2]:


get_ipython().system('pip install river')
get_ipython().system('pip install pytest')
get_ipython().system('pip install scikit-learn')
get_ipython().system('pip install matplotlib')
get_ipython().system('pip install requests')
get_ipython().system('pip install streamlit')
get_ipython().system('pip install numpy as np')


# In[4]:


import logging
# Import libraries in this section.
# Avoid imports like import *, from ... import ..., from ... import *, etc.
import time
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import warnings
import collections

import river
import river.linear_model
import river.tree
import river.metrics
import river.optim
from river import linear_model
from river import metrics
import bitcoin_forecast_utils
from bitcoin_forecast_utils import (
    get_bitcoin_price_with_retry,
    get_coin_ohlc,
    build_rolling_features
)
from collections import deque
from river import preprocessing
from river import tree
import requests
import pickle
import streamlit as st


# # Initialize Model, Metric, Rolling Structures
# This cell performs essential setup for real-time streaming:
# 
# - **Model Initialization**: Uses River's `StandardScaler` and `LinearRegression` in a pipeline to handle online feature normalization and regression.
# - **Metric**: Initializes `MAE` (Mean Absolute Error) for evaluating prediction accuracy incrementally.
# - **Rolling Window**: Creates a `deque` to maintain the most recent 5 Bitcoin prices for feature engineering.
# - **Logging**: Prepares empty lists to store MAE values, predictions, and actual prices for post-streaming visualization and analysis.

# In[5]:


# Initialize River model and metric
model = preprocessing.StandardScaler() | linear_model.LinearRegression()
metric = metrics.MAE()

# Rolling window to hold past prices (lagged features)
rolling_prices = deque(maxlen=5)

# Logs for analysis and plotting
mae_log = []
pred_log = []
true_log = []


# ##  Real-Time Streaming + Online Model Training
# This block simulates **real-time model training** using cached OHLC close prices. Here's what each part does:
# 
# - **OHLC Fetch**: Retrieves 1 day of close prices from the CoinGecko API via `get_coin_ohlc(days=1)` to mimic a live stream.
# - **Streaming Simulation**: Iterates through the close prices one-by-one as if theyâ€™re arriving in real time.
# - **Rolling Window**: Appends each new price to a `deque`, maintaining only the latest 5 values.
# - **Feature Engineering**: Constructs combined features using both price lags and OHLC-derived volatility indicators.
# - **Model Prediction**: Makes a prediction using the current model.
# - **Model Training**: If a prediction is available, the model is updated with the actual target using `learn_one()`.
# - **Metric Update**: The MAE (Mean Absolute Error) is updated incrementally for evaluation.
# - **Logging**: Records MAE, prediction, and actual values for later plotting.
# 
# This structure supports **streaming learning** with continuous model updates, performance tracking, and feature interaction using River.

# In[6]:


# Simulate real-time from cached OHLC close prices
ohlc_df = get_coin_ohlc(days=1)
for step, price in enumerate(ohlc_df["close"].head(30)):
    rolling_prices.append(price)

    if len(rolling_prices) < rolling_prices.maxlen:
        continue

    #features = build_rolling_features(rolling_prices)
    ohlc_features_df = bitcoin_forecast_utils.extract_ohlc_features(ohlc_df)
    features = bitcoin_forecast_utils.build_combined_features(rolling_prices, ohlc_features_df)
    true_price = features["price_lag_0"]
    pred_price = model.predict_one(features)

    if pred_price is not None:
        model.learn_one(features, true_price)
        metric = metric.update(true_price, pred_price)

        mae_log.append(metric.get())
        pred_log.append(pred_price)
        true_log.append(true_price)


# 
# This log message is generated by the `get_coin_ohlc()` function from the `bitcoin_forecast_utils.py` module.
# 
#  What It Means:
# - The notebook **did not fetch fresh OHLC data** from the CoinGecko API.
# - Instead, it **loaded previously saved OHLC data** from a local CSV file (`cached_ohlc.csv`).
# - This behavior is controlled by the caching mechanism to improve efficiency and reduce API calls.
# 
#  Why This Is Useful:
# - **Faster Execution:** Avoids unnecessary API calls.
# - **Rate Limit Protection:** Prevents hitting CoinGeckoâ€™s usage limits.
# - **Reproducibility:** Ensures consistent results during testing or demonstration.

# ## Plot Rolling MAE Over Time
# This cell visualizes the **Mean Absolute Error (MAE)** of the model predictions over time.

# In[7]:


#  Plot Rolling MAE Over Time
plt.figure(figsize=(10, 5))
plt.plot(mae_log, label='Rolling MAE')
plt.xlabel('Time Step')
plt.ylabel('Mean Absolute Error')
plt.title('MAE Over Time (Streaming)')
plt.legend()
plt.grid(True)
plt.tight_layout()
plt.show()


# The curve steadily decreases over time, showing that the model is learning and improving.
# 
# This means the modelâ€™s predictions are getting closer to actual values as more data is ingested.
# 
# The presence of a smooth downward slope is a strong indicator that the streaming learning process is working correctly.

# ## Plot Predicted vs True Bitcoin Price
# This cell visualizes the **streaming predictions** made by the model and compares them against the **actual observed Bitcoin prices** over time.
# 

# In[8]:


#  Plot Predicted vs True Bitcoin Price
plt.figure(figsize=(10, 5))
plt.plot(pred_log, label="Predicted Price", linestyle="--", marker="o")
plt.plot(true_log, label="Actual Price", linestyle="-", marker="x")
plt.xlabel("Time Step")
plt.ylabel("Bitcoin Price (USD)")
plt.title("Predicted vs Actual Bitcoin Price")
plt.legend()
plt.grid(True)
plt.tight_layout()
plt.show()


# The actual price remains relatively stable, reflecting realistic Bitcoin pricing behavior.
# 
# The predicted prices initially deviate strongly â€” showing some overfitting or instability during early updates.
# 
# Over time, the predictions begin to stabilize and converge toward the actual values, especially after time step ~15.
# 
# This highlights the nature of online learning: the model starts with high error but improves incrementally with each new data point.
# 
# we can clearly observe that the model gradually learns to follow the trend of the real prices, though some volatility in prediction remains.

# ## Print Model Weights
# This cell prints the **learned weights** from the linear regression model to understand which features (lags and indicators) are contributing most to predictions.
# 

# In[9]:


# Inspect model weights (feature importance)
print("Model Weights:")
for feature, weight in model[-1].weights.items():
    print(f"{feature}: {weight:.4f}")


# ## Simulated Retry Logic (API Robustness Test)
# This cell simulates an API failure scenario to test the robustness of the retry mechanism implemented in `bitcoin_forecast_utils.py`.
# 

# In[10]:


#  Simulate API failure to demonstrate retry mechanism
def simulate_api_failure():
    raise requests.exceptions.HTTPError(response=requests.Response())

try:
    simulate_api_failure()
except requests.exceptions.HTTPError:
    print("Retry mechanism would be triggered here (simulated).")


# ##  Save the Trained River Model with Pickle
# This cell demonstrates how to serialize and persist the trained River model using the `pickle` module.
# 

# In[11]:


# Save trained River model to a pickle file
with open("btc_stream_model.pkl", "wb") as f:
    pickle.dump(model, f)

print(" Model saved to btc_stream_model.pkl")


# ## Basic Streaming with OHLC and Linear Regression
# This cell demonstrates a simple pipeline for streaming Bitcoin close prices and updating a linear regression model using lag features.

# In[12]:


# 2.12 Basic Streaming with OHLC Close Prices and Linear Regression

ohlc_df = get_coin_ohlc("bitcoin", vs_currency="usd", days=7)
ohlc_prices = ohlc_df["close"].tolist()

rolling_window = deque(maxlen=5)
model = linear_model.LinearRegression()
metric = metrics.MAE()

for price in ohlc_prices[:30]:
    rolling_window.append(price)

    if len(rolling_window) < rolling_window.maxlen:
        continue

    features = build_rolling_features(rolling_window)
    y_pred = model.predict_one(features)
    y_true = features["price_lag_0"]

    if y_pred is not None:
        model.learn_one(features, y_true)
        metric = metric.update(y_true, y_pred)

    rolling_window.append(price)

print(" MAE using OHLC Close Prices:", metric.get())


# ## Multi-Model Streaming and Volatility Analysis
# This cell demonstrates the use of multiple River modelsâ€”Linear Regression, Hoeffding Tree Regressor, and a Scaled Linear Regression pipelineâ€”to forecast Bitcoin prices using a streaming approach. It also tracks volatility for interpretability.

# In[13]:


# ---- Initialization ----
ohlc_df = get_coin_ohlc(days=1)
close_prices = ohlc_df["close"].head(50)  # You can increase this range
rolling_prices = deque(maxlen=5)

# Models
lr_model = linear_model.LinearRegression()
tree_model = tree.HoeffdingTreeRegressor()
pipeline_model = preprocessing.StandardScaler() | linear_model.LinearRegression()

# Logs
actual_log, lr_log, tree_log, pipe_log, vol_log = [], [], [], [], []

# ---- Streaming Loop ----
for step, price in enumerate(close_prices):
    rolling_prices.append(price)
    if len(rolling_prices) < rolling_prices.maxlen:
        continue

    features = build_rolling_features(rolling_prices)
    actual = price

    # Predictions
    lr_pred = lr_model.predict_one(features) if step > rolling_prices.maxlen else 0
    tree_pred = tree_model.predict_one(features) if step > rolling_prices.maxlen else 0
    pipe_pred = pipeline_model.predict_one(features) if step > rolling_prices.maxlen else 0

    # Logging
    actual_log.append(actual)
    lr_log.append(lr_pred)
    tree_log.append(tree_pred)
    pipe_log.append(pipe_pred)
    vol_log.append(ohlc_df["high"].iloc[step] - ohlc_df["low"].iloc[step])

    # Training
    lr_model.learn_one(features, actual)
    tree_model.learn_one(features, actual)
    pipeline_model.learn_one(features, actual)

# ---- Print Output ----
print(f"{'Step':<6} {'Actual':>10} | {'LR':>10} | {'Tree':>10} | {'Pipe':>10} | {'Volatility':>12}")
print("-" * 65)
for i, (a, l, t, p, v) in enumerate(zip(actual_log, lr_log, tree_log, pipe_log, vol_log)):
    print(f"[{i:<3}] {a:10.2f} | {l:10.2f} | {t:10.2f} | {p:10.2f} | {v:12.2f}")


#  Prints a neatly formatted row-by-row comparison showing:
#   - Time step
#   - Actual price
#   - Predicted prices from LR, Tree, and Pipeline
#   - Rolling volatility

# ## Visualization: Predicted vs Actual Comparison Across Models
# This cell provides a comprehensive visual comparison of the performance of multiple models over time and visualizes the volatility of Bitcoin prices.
# 
#  Top Plot â€” Model Predictions vs Actual Price
# - Compares predicted Bitcoin prices from:
#   - Linear Regression
#   - Hoeffding Tree Regressor
#   - Pipeline (StandardScaler + Linear Regression)
# - Uses distinct colors and markers for clarity.
# - Plots them against the actual price across time steps.
# 
# **Insight:** The closer the predicted lines are to the actual line, the better the modelâ€™s performance.
# 
# Bottom Plot â€” Rolling Volatility (Standard Deviation)
# - Displays the rolling volatility of Bitcoin prices (i.e., std deviation of the high-low spread).
# - Helps identify periods of high market uncertainty or price fluctuation.
# 
# **Insight:** Volatility spikes often indicate sudden price movements which models may struggle to predict accurately.

# In[14]:


# 2.14 Visualization: Multi-Model Comparison

plt.figure(figsize=(12, 6))
plt.plot(actual_log, label="Actual Price", linewidth=2, marker='o')
plt.plot(lr_log, label="Linear Regression", linestyle='--', marker='x')
plt.plot(tree_log, label="Hoeffding Tree", linestyle='-.', marker='^')
plt.plot(pipe_log, label="Pipeline (Scaled LR)", linestyle=':', marker='s')
plt.title("Bitcoin Price Prediction: Multi-Model Comparison")
plt.xlabel("Time Step")
plt.ylabel("Price (USD)")
plt.legend()
plt.grid(True)
plt.tight_layout()
plt.show()

# Optional: Volatility plot
plt.figure(figsize=(10, 4))
plt.plot(vol_log, label="Rolling Volatility (std dev)", color='purple')
plt.title("Rolling Volatility of Bitcoin Prices")
plt.xlabel("Time Step")
plt.ylabel("Standard Deviation")
plt.grid(True)
plt.tight_layout()
plt.legend()
plt.show()


# # Streamlit Integration with Trained River Model
# This cell integrates a pre-trained River model into a live Streamlit app for real-time forecasting and dynamic visualization.

# In[16]:


# Load trained model
with open("btc_stream_model.pkl", "rb") as f:
    model = pickle.load(f)

# Streamlit UI
st.title(" Real-Time Bitcoin Price Forecasting (River)")

# Fetch price
try:
    current_price = get_bitcoin_price_with_retry()
    st.metric(" Current BTC Price (USD)", f"${current_price:,.2f}")
except Exception as e:
    st.error(f"Failed to fetch price: {e}")
    st.stop()

# Simulate rolling window
if "rolling_prices" not in st.session_state:
    st.session_state.rolling_prices = deque(maxlen=5)

st.session_state.rolling_prices.append(current_price)

# Only forecast if we have enough history
if len(st.session_state.rolling_prices) == 5:
    features = build_rolling_features(st.session_state.rolling_prices)
    prediction = model.predict_one(features)

    # Display prediction
    st.subheader("Predicted Next Price")
    st.success(f"${prediction:,.2f}")

    # Train the model (simulate online learning)
    model.learn_one(features, current_price)

    # Save updated model
    with open("btc_stream_model.pkl", "wb") as f:
        pickle.dump(model, f)

    # Show weights
    st.subheader("Model Weights")
    st.json(model.weights)

    # Plot true vs predicted
    if "price_log" not in st.session_state:
        st.session_state.price_log = []

    st.session_state.price_log.append((current_price, prediction))

    df = pd.DataFrame(st.session_state.price_log, columns=["Actual", "Predicted"])
    st.line_chart(df)


# In[17]:


code = '''
import streamlit as st
import time
import pickle
from collections import deque
from bitcoin_forecast_utils import get_bitcoin_price_with_retry, build_rolling_features
from river import linear_model, metrics, preprocessing

# App Config
st.set_page_config(page_title="Bitcoin Forecasting with River", page_icon=":chart_with_upwards_trend:")
st.title("ðŸ“ˆ Real-Time Bitcoin Price Forecasting using River")

# Load or initialize model with normalization
if "model" not in st.session_state:
    scaler = preprocessing.StandardScaler()
    regressor = linear_model.LinearRegression()
    st.session_state.model = scaler | regressor
    st.session_state.metric = metrics.MAE()
    st.session_state.rolling_prices = deque(maxlen=5)
    st.session_state.price_log = []

model = st.session_state.model
metric = st.session_state.metric
rolling_prices = st.session_state.rolling_prices
price_log = st.session_state.price_log

# Fetch live price
if st.button("ðŸ”„ Refresh BTC Price"):
    get_bitcoin_price_with_retry.cache_clear()
    st.rerun()

try:
    current_price = get_bitcoin_price_with_retry()
    st.metric("ðŸ“Œ Current BTC Price (USD)", f"${current_price:,.2f}")
except Exception as e:
    st.error(f"Failed to fetch price: {e}")
    st.stop()

# Update rolling window
rolling_prices.append(current_price)

# Predict only if enough data is available
if len(rolling_prices) == rolling_prices.maxlen:
    features = build_rolling_features(rolling_prices)
    pred_price = model.predict_one(features)

    # Display prediction
    # TEMP FIX: Add predicted delta to current price
    prediction = model.predict_one(features)
    corrected_prediction = current_price + prediction
    st.subheader("ðŸ§  Predicted Next Price")
    st.success(f"${corrected_prediction:,.2f}")


    # Train model
    model.learn_one(features, current_price)
    metric = metric.update(current_price, pred_price)
    st.session_state.metric = metric

    # Log data
    price_log.append((current_price, pred_price))

# Optional: Show model weights
if st.checkbox("ðŸ” Show Model Weights"):
    try:
        weights = dict(model[-1].weights)
        st.json(weights)
        st.line_chart(list(weights.values()))
    except Exception as e:
        st.error("Could not display weights: " + str(e))

# Optional: Display log chart
if price_log:
    import pandas as pd
    df = pd.DataFrame(price_log, columns=["Actual", "Predicted"])
    st.line_chart(df)

'''

# Save to a file
with open("streamlit_app.py", "w") as f:
    f.write(code)

print(" Streamlit app saved to streamlit_app.py")


# In[ ]:


get_ipython().system('streamlit run streamlit_app.py')


# In[ ]:




