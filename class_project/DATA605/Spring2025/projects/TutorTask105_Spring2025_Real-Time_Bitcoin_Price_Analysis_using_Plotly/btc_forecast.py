# -*- coding: utf-8 -*-
"""btc_forecast

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ICdKaBnG3zQe090LeNqNoN1aOHH7UhJ2
"""


"""**Bitcoin Price Forecast with LSTM – Code Walkthrough**

This script is a complete Bitcoin (BTC) price analysis and forecasting tool that fetches historical BTC/USD data from the Kraken exchange and builds a predictive model using a Long Short-Term Memory (LSTM) neural network. It is designed following the Causify coding style guidelines and uses interactive Plotly charts for visualization. The goal is to provide insights into past BTC behavior and forecast its price for the next 60 minutes using ~10,000 minutes of historical data at 1-minute granularity.

The script begins by defining two primary classes. The BTCPriceTracker class handles communication with Kraken’s public API, fetching both the latest real-time price and historical OHLC (Open, High, Low, Close) data. This data is cleaned, converted into a pandas DataFrame, and structured to isolate the closing prices for time series modeling. The second class, BTCForecaster, contains methods for normalizing the data, constructing input/output sequences, training an LSTM model, and generating a 60-minute forecast from the most recent observed window.

After retrieving the data, the script splits it into training and testing sets. It uses TensorFlow’s Sequential API to define and train the LSTM model. The model takes 60-minute input windows and learns to predict the next 60-minute sequence of prices. Once trained, the model makes a prediction based on the most recent data window. The prediction is then evaluated using two metrics—Mean Absolute Error (MAE) and Mean Squared Error (MSE)—to quantify the model’s performance compared to the actual BTC prices in the last hour.

Finally, the plot_full_dashboard() function generates four interactive Plotly visualizations: (1) BTC Price with SMA, (2) Volatility Bands, (3) Percent Change Plot, and (4) Forecast vs Actual plot. These plots offer intuitive visual insights into BTC price trends, fluctuations, and model performance. This consolidated analysis makes the script a powerful exploratory and predictive tool for traders, analysts, or researchers interested in financial time series forecasting.
"""

"""
Bitcoin Price Forecast using Kraken API and LSTM Model (Plotly Version).

1. Kraken API Reference: https://docs.kraken.com/rest/
2. LSTM methodology from TensorFlow Keras documentation:
   https://www.tensorflow.org/api_docs/python/tf/keras/layers/LSTM
3. Conforms to the Causify coding style guide:
   https://github.com/causify-ai/helpers/blob/master/docs/coding/all.coding_style.how_to_guide.md
"""

import logging
from typing import Optional, Tuple
import requests
import pandas as pd
import numpy as np
from datetime import datetime, timedelta
from sklearn.preprocessing import MinMaxScaler
from sklearn.metrics import mean_squared_error, mean_absolute_error
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import LSTM, Dense
import plotly.graph_objects as go
from plotly.subplots import make_subplots

_LOG = logging.getLogger(__name__)


class BTCPriceTracker:
    def get_latest_price(self) -> Optional[float]:
        """
        Fetches the latest real-time BTC/USD price using Kraken's public API.

        :return: Current BTC price in USD or None if API call fails.
        """
        url = "https://api.kraken.com/0/public/Ticker?pair=XBTUSD"
        response = requests.get(url)
        if response.status_code == 200:
            data = response.json()
            try:
                return float(data['result']['XXBTZUSD']['c'][0])
            except KeyError:
                return None
        return None

    def get_historical_data(self, minutes: int = 10000, interval: int = 1) -> pd.DataFrame:
        """
        Retrieves historical OHLC BTC/USD data from Kraken over a given interval.

        :param minutes: Number of minutes of data to retrieve.
        :param interval: Time interval in minutes between data points.
        :return: DataFrame containing 'close' prices with datetime index.
        """
        end_time = int(datetime.now().timestamp())
        start_time = int((datetime.now() - timedelta(minutes=minutes)).timestamp())
        url = f"https://api.kraken.com/0/public/OHLC?pair=XBTUSD&since={start_time}&interval={interval}"
        response = requests.get(url)
        if response.status_code == 200:
            data = response.json()
            if 'result' in data and 'XXBTZUSD' in data['result']:
                df = pd.DataFrame(data['result']['XXBTZUSD'], columns=[
                    'time', 'open', 'high', 'low', 'close', 'vwap', 'volume', 'count'])
                df['time'] = pd.to_datetime(df['time'], unit='s')
                df.set_index('time', inplace=True)
                df['close'] = df['close'].astype(float)
                return df[['close']]
        return pd.DataFrame()


class BTCForecaster:
    def __init__(self):
        """
        Initializes the LSTM model structure and preprocessing tools.

        :return: None
        """
        self.model = None
        self.scaler = MinMaxScaler()
        self.sequence_length = 60

    def prepare_sequences(self, df: pd.DataFrame) -> Tuple[np.ndarray, np.ndarray]:
        """
        Transforms historical price data into LSTM-ready input/output sequences.

        :param df: DataFrame of close prices.
        :return: Tuple of input (X) and output (y) sequences for LSTM.
        """
        scaled = self.scaler.fit_transform(df[['close']])
        X, y = [], []
        for i in range(self.sequence_length, len(scaled) - 60):
            X.append(scaled[i - self.sequence_length:i])
            y.append(scaled[i:i + 60])
        return np.array(X), np.array(y)

    def train_model(self, X: np.ndarray, y: np.ndarray) -> None:
        """
        Builds and trains an LSTM neural network for sequence prediction.

        :param X: Input sequences for training.
        :param y: Target output sequences.
        :return: None
        """
        self.model = Sequential()
        self.model.add(LSTM(64, return_sequences=False, input_shape=(X.shape[1], 1)))
        self.model.add(Dense(60))
        self.model.compile(optimizer='adam', loss='mse')
        self.model.fit(X, y, epochs=5, batch_size=64, verbose=1)

    def forecast(self, last_window: np.ndarray) -> np.ndarray:
        """
        Predicts the next 60 BTC prices using the most recent input window.

        :param last_window: The most recent 60-minute normalized sequence.
        :return: Forecasted 60 BTC prices in original scale.
        """
        prediction = self.model.predict(last_window.reshape(1, self.sequence_length, 1))
        return self.scaler.inverse_transform(prediction.reshape(-1, 1)).flatten()


def evaluate_predictions(true_vals: np.ndarray, predicted: np.ndarray) -> Tuple[float, float]:
    """
    Calculates MAE and MSE between true and predicted BTC price values.

    :param true_vals: Ground truth price values.
    :param predicted: LSTM model predictions.
    :return: Tuple containing MAE and MSE.
    """
    mae = mean_absolute_error(true_vals, predicted)
    mse = mean_squared_error(true_vals, predicted)
    return mae, mse


def plot_full_dashboard(df: pd.DataFrame, true_vals: np.ndarray, predicted: np.ndarray) -> None:
    """
    Generates a full Plotly dashboard including SMA, Volatility, % Change, and Forecast plots.

    :param df: Historical price DataFrame.
    :param true_vals: Last 60 true BTC prices.
    :param predicted: Predicted next 60 BTC prices.
    :return: None
    """
    df = df.copy()
    df.rename(columns={'close': 'Price'}, inplace=True)
    df['SMA_5'] = df['Price'].rolling(window=5).mean()
    df['Volatility'] = df['Price'].rolling(window=5).std()
    df['Pct_Change'] = df['Price'].pct_change() * 100

    # Plot 1: Price + SMA
    fig1 = go.Figure()
    fig1.add_trace(go.Scatter(x=df.index, y=df['Price'], name='Price'))
    fig1.add_trace(go.Scatter(x=df.index, y=df['SMA_5'], name='5-Point SMA', line=dict(dash='dash')))
    fig1.update_layout(title="BTC Price with Simple Moving Average",
                       xaxis_title="Time", yaxis_title="Price (USD)",
                       template="plotly_white")
    fig1.show()

    # Plot 2: Volatility Bands
    fig2 = go.Figure()
    fig2.add_trace(go.Scatter(x=df.index, y=df['Price'], name='Price'))
    fig2.add_trace(go.Scatter(
        x=df.index,
        y=df['Price'] + df['Volatility'],
        name='+1 Std Dev', line=dict(width=0), showlegend=False))
    fig2.add_trace(go.Scatter(
        x=df.index,
        y=df['Price'] - df['Volatility'],
        name='Volatility Band', fill='tonexty',
        fillcolor='rgba(0,100,80,0.2)', line=dict(width=0)))
    fig2.update_layout(title="Bitcoin Price Volatility Bands",
                       xaxis_title="Time", yaxis_title="Price (USD)",
                       template="plotly_white")
    fig2.show()

    # Plot 3: Percent Change
    fig3 = go.Figure()
    fig3.add_trace(go.Scatter(x=df.index, y=df['Pct_Change'], name='% Change', line=dict(color='orange')))
    fig3.add_trace(go.Scatter(x=df.index, y=[0]*len(df), name='Zero Line',
                              line=dict(dash='dash', color='gray')))
    fig3.update_layout(title="BTC Price % Change Over Time",
                       xaxis_title="Time", yaxis_title="Percent Change (%)",
                       template="plotly_white")
    fig3.show()

    # Plot 4: Forecast vs Actual
    fig4 = go.Figure()
    fig4.add_trace(go.Scatter(y=true_vals, mode='lines+markers', name='Actual (Last 60 min)'))
    fig4.add_trace(go.Scatter(y=predicted, mode='lines+markers',
                              name='Forecast (Next 60 min)', line=dict(dash='dash')))
    fig4.update_layout(title='Bitcoin Price Forecast (LSTM)',
                       xaxis_title='Minutes Ahead',
                       yaxis_title='Price (USD)',
                       template='plotly_white')
    fig4.show()


if __name__ == "__main__":
    fetcher = BTCPriceTracker()
    forecaster = BTCForecaster()

    df = fetcher.get_historical_data()
    if df.empty:
        raise Exception("Failed to retrieve historical data.")

    X, y = forecaster.prepare_sequences(df)
    split = int(0.8 * len(X))
    X_train, y_train = X[:split], y[:split]
    X_test, y_test = X[split:], y[split:]

    forecaster.train_model(X_train, y_train)

    last_window = X[-1]
    prediction = forecaster.forecast(last_window)
    actual = df['close'].iloc[-60:].values

    mae, mse = evaluate_predictions(actual, prediction)
    print("\n📈 LSTM Forecast Evaluation:")
    print(f"Mean Absolute Error (MAE): {mae:.2f}")
    print(f"Mean Squared Error (MSE): {mse:.2f}")

    plot_full_dashboard(df, actual, prediction)