// Dir is https://drive.google.com/drive/folders/1u8ZUAkLc8yZBwGgXvfBcAY_oSCyzT_pp
//
// https://docs.google.com/presentation/d/1XnaVECt0YkkPBt-7TDuOBRGHSba9fiSuodAXECf2-tc/edit?slide=id.p42#slide=id.p42

::: columns
:::: {.column width=15%}
![](msml610/lectures_source/figures/UMD_Logo.png)
::::
:::: {.column width=75%}

\vspace{0.4cm}
\begingroup \large
UMD DATA605 - Big Data Systems
\endgroup
::::
:::

\vspace{1cm}

\begingroup \Large
**$$\text{\blue{Relational DBs}}$$**
\endgroup

::: columns
:::: {.column width=75%}
\vspace{1cm}

**Instructor**: Dr. GP Saggese, [gsaggese@umd.edu](gsaggese@umd.edu)

::::
:::: {.column width=20%}

::::
:::

* Relational Model: Overview
- Introduced by Ted Codd (late 60's, early 70's)

- **First prototypes**
  - Ingres Project at Berkeley (1970-1985)
    - Ingres (INteractive Graphics REtrieval System)
    - $\to$ PostgreSQL (=Post Ingres)
  - IBM System R (1970) $\to$ Oracle, IBM DB2

- **Contributions from relational data model**
  - Formal semantics for data operations
  - Data independence: separation of logical and physical data models
  - Declarative query languages (e.g., SQL)
  - Query optimization

- **Key to commercial success**

* Relational Model: Key Definitions
::: columns
:::: {.column width=55%}
- A relational DB consists of a collection of **tables / relations**
  - Each table has a unique name and schema

- Each **row / tuple / record** in a table represents a relationship among
  values

- Each **element** of a row corresponds to a **column / field / attribute**
  - Each element in a column is atomic (e.g., a phone number is a single object)
  - `NULL` represents a value that is unknown or doesn't exist

- E.g., `instructor` and `course` relations

- **Schema of a relation**
  - A list of attributes and their domains
  - Like type definition in programming languages
  - E.g., the domain of `salary` is integers >= 0

- **Instance of relation**
  - A particular instantiation of a relation with actual values
  - Changes over time
::::
:::: {.column width=40%}

\centering

\footnotesize

![](data605/lectures_source/images/lecture_4_1/lec_4_1_slide_4_image_1.png){width=60%}
`instructor` relation

\vspace{1cm}

![](data605/lectures_source/images/lecture_4_1/lec_4_1_slide_4_image_2.png)
`course` relation

::::
:::

* UML Class Diagram
::: columns
:::: {.column width=55%}
- UML class diagram
  - UML = Unified Modeling Language
  - Used in OOP and DB design
- **In OOP design**
  - Diagram showing classes, attributes, methods, and relationships

\vspace{2cm}

- **In DB design**
  - Each box is a table / relation
  - Columns / fields / attributes are listed inside the box
  - Primary keys are underlined
  - Foreign key constraints are arrows
::::
:::: {.column width=40%}

\centering

![](data605/lectures_source/images/lecture_4_1/lec_4_1_slide_5_image_1.png)

![](data605/lectures_source/images/lecture_4_1/lec_4_1_slide_5_image_2.png){ width=60% }

![](data605/lectures_source/images/lecture_4_1/lec_4_1_slide_5_image_3.png)

![](data605/lectures_source/images/lecture_4_1/lec_4_1_slide_5_image_4.png){ width=60% }

::::
:::

* Example: University DB

- **UML diagram of a DB and schemas representing a University**
  - Each box is a table / relation
  - Column / fields / attributes are listed inside the box
  - Primary keys are underlined fields
  - Foreign key constraints are arrows between boxes

::: columns
:::: {.column width=40%}
- **Analysis of the diagram**
  - ER model
  - Entities
    - `student`
    - `department`
    - ...
  - Relationships
    - `takes`
    - `teaches`
    - ...
::::
:::: {.column width=55%}
![](data605/lectures_source/images/lecture_4_1/lec_4_1_slide_6_image_1.png)
::::
:::

* Primary Key
::: columns
:::: {.column width=65%}

- _R_ is the set of attributes of a relation _r_
  - E.g., `ID, name, dept_name, salary` are attributes of relation `instructor`

- _K_ is a superkey of _R_ if values for _K_ identify a unique tuple of each
  possible relation _r(R)_
  - E.g., `(ID)` and `(ID, name)` are superkeys of `instructor`
  - `(name)` is not a superkey of `instructor`

- A primary key is a minimal set of attributes that uniquely identify each row
  - Typically small and immutable
  - Would `SSN` be a primary key? Yes and no

- **Primary key constraint**: rows can't have the same primary key

::::
:::: {.column width=35%}

\centering
![](data605/lectures_source/images/lecture_4_1/lec_4_1_slide_7_image_1.png)
\footnotesize
`instructor` relation

\vspace{1cm}
![](data605/lectures_source/images/lecture_4_1/lec_4_1_slide_7_image_2.png){width=50%}
::::
:::

* Question: What are Primary Keys?
::: columns
:::: {.column width=75%}
- Marital status
  - Married(person1\_ssn, person2\_ssn, date\_married, date\_divorced)

- Bank account
  - Account(cust\_ssn, account\_number, cust\_name, balance, cust\_address)

- Research assistantship at UMD
  - RA(student\_id, project\_id, supervisor\_id, appt\_time, appt\_start\_date,
    appt\_end\_date)

- Information typically found on Wikipedia
  - Person(Name, Born, Died, Citizenship, Education, ...)

- Info about US President on Wikipedia
  - President(name, start\_date, end\_date, vice\_president, preceded\_by,
    succeeded\_by)

- Tour de France: historical rider participation information
  - Rider(Name, Born, Team-name, Coach, Sponsor, Year)
::::
:::: {.column width=25%}

![](data605/lectures_source/images/lecture_4_1/lec_4_1_slide_8_image_1.png)
::::
:::

* Answer: What are Primary Keys?
::: columns
:::: {.column width=75%}
- Marital status
  - Married(**person1\_ssn, person2\_ssn, date\_married**, date\_divorced)

- Bank account
  - Account(cust\_ssn, **account\_number**, cust\_name, balance, cust\_address)

- Research assistantship at UMD
  - RA(**student\_id, project\_id**, supervisor\_id, appt\_time,
    **appt\_start\_date**, appt\_end\_date)

- Information typically found on Wikipedia
  - Person(**Name, Born, Died, Citizenship, Education, ...**)

- Info about US President on Wikipedia
  - President(**name, start\_date**, end\_date, vice\_president, preceded\_by,
    succeeded\_by)

- Tour de France: historical rider participation information
  - Rider(**Name, Born, Team-name,** Coach, Sponsor, **Year**)
::::
:::: {.column width=25%}
![](data605/lectures_source/images/lecture_4_1/lec_4_1_slide_9_image_1.png)
::::
:::

* Foreign Key
::: columns
:::: {.column width=60%}
- **Foreign key** = primary key of a relation in another relation
  - E.g., `(ID)` from `student` in `takes`, `advisor`
  - `takes` is the "referencing relation", has the foreign key
  - `student` is the "referenced relation", has the primary key
  - Shown by an arrow from referencing $\to$ referenced
::::
:::: {.column width=35%}
![](data605/lectures_source/images/lecture_4_1/lec_4_1_slide_10_image_1.png)
::::
:::

- **Foreign key constraint**: for each row, the tuple for a primary key must
  exist
  - Aka referential integrity constraint
  - If `(student101, DATA605)` in `takes`, there must be `student101` in
    `student`

- The key referenced as foreign key needs to exist as primary key


* Relational Algebra: 1/4
::: columns
:::: {.column width=70%}
- **Relation**: set of tuples

- **Relational algebra**: operations on relations producing a new relation
  - Unary: selection, projection, rename
  - Binary: union, set difference, intersection, Cartesian product, join

- **Selection $\Sigma$**: select tuples satisfying a predicate
  - E.g., select `instructor` tuples where `dept_name = "Physics"`

- **Projection $\pi$**: return tuples with subset of attributes
  - E.g., project `instructor` tuples with `(name, salary)`

- **Set operations**: union, intersection, set difference
  - Must be compatible (same attributes)
::::
:::: {.column width=30%}

![](data605/lectures_source/images/lecture_4_1/lec_4_1_slide_11_image_1.png)

![](data605/lectures_source/images/lecture_4_1/lec_4_1_slide_11_image_2.png)

![](data605/lectures_source/images/lecture_4_1/lec_4_1_slide_11_image_3.png){width=90%}

\vspace{0.5cm}

![](data605/lectures_source/images/lecture_4_1/lec_4_1_slide_11_image_4.png){width=80%}

![](data605/lectures_source/images/lecture_4_1/lec_4_1_slide_11_image_5.png){width=80%}

::::
:::

* Relational Algebra: 2/4
- **Cartesian product**: combine information from two relations into a new one
  - `instructor` = `(ID, name, dept_name, salary)`
  - `teaches` = `(ID, course_id, sec_id, semester, year)``
- E.g., `instructor` x `teaches` gives
  `(instructor.ID, instructor.name, instructor.dept_name, teaches.ID, ...)`

::: columns
:::: {.column width=25%}
![](data605/lectures_source/images/lecture_4_1/lec_4_1_slide_12_image_1.png)

\footnotesize
`instructor` relation
::::
:::: {.column width=30%}
![](data605/lectures_source/images/lecture_4_1/lec_4_1_slide_12_image_2.png)

\footnotesize
`teaches` relation
::::
:::: {.column width=45%}
![](data605/lectures_source/images/lecture_4_1/lec_4_1_slide_12_image_3.png){width=90%}

\footnotesize
`instructor` x `teaches`
::::
:::

* Relational Algebra: 3/4

- **Join**: composition of two operations
  - Cartesian-product
  - A selection based on equality between two fields
  - E.g., `instructor` x `teaches` when `instructor.ID = teaches.ID`

::: columns
:::: {.column width=25%}

![](data605/lectures_source/images/lecture_4_1/lec_4_1_slide_13_image_3.png)
\footnotesize
`instructor` relation

::::
:::: {.column width=30%}

![](data605/lectures_source/images/lecture_4_1/lec_4_1_slide_13_image_4.png)
\footnotesize
`teaches` relation

::::
:::: {.column width=45%}

![](data605/lectures_source/images/lecture_4_1/lec_4_1_slide_13_image_1.png)
![](data605/lectures_source/images/lecture_4_1/lec_4_1_slide_13_image_2.png){width=80%}

::::
:::

* Relational Algebra: 4/4
::: columns
:::: {.column width=55%}
- **Query**: combination of relational algebra operations
  - E.g., _"find `course_id` from table section for fall 2017"_

- **Assignment**: assign parts of relational algebra to temporary relation
  variables
  - Write a query as a sequential program
  - E.g., _"find `course_id` for classes in both fall 2017 and spring 2018"_

- **Equivalent queries**: two queries giving the same result on any DB instance
  - Some formulations are more efficient
::::
:::: {.column width=40%}

![](data605/lectures_source/images/lecture_4_1/lec_4_1_slide_14_image_2.png)

\vspace{2cm}

![](data605/lectures_source/images/lecture_4_1/lec_4_1_slide_14_image_1.png)

::::
:::

* SQL Overview

- **Relational algebra**: mathematical language to manipulate _relations_

- **SQL**: language to describe and transform data in a relational DB
  - Originally Sequel
  - Changed to Structured Query Language

- **SQL statements grouped by goal**
  - Data definition language (DDL)
    - Define schema (tables, attributes, indices)
    - Specify integrity constraints (primary key, foreign key, not null)
  - Data modification language (DML)
    - Modify data in tables
    - Insert, Update, Delete
  - Query data (DQL)
  - Control transactions
    - Specify beginning and end, control isolation level
  - Define views
  - Authorization
    - Specify access and security constraints

* SQL Overview

- Data description language (DDL)
  ```sql
  CREATE TABLE <name> (<field> <domain>, ... )
  ```

- Data modification language (DML)
  ```sql
  INSERT INTO <name> (<field names>) VALUES (<field values>)
  DELETE FROM <name> WHERE <condition>
  UPDATE <name> SET <field name> = <value> WHERE <condition>
  ```

- Query language
  ```sql
  SELECT <fields> FROM <name> WHERE <condition>
  ```

* Create Table

:::columns
::::{.column width=50%}
```sql 
  CREATE TABLE r
   (A_1 D_1, 
   A_2 D_2, 
   ..., 
   A_n D_n, 
   IntegrityConstraint_1, 
   IntegrityConstraint_n); 
```
::::
::::{.column width=50%}
where:

- `r` is name of *table* (aka *relation*)
- `A_i` name of *attribute* (aka *field*, *column*)
- `D_i` domain of attribute `A_i`
::::
:::

- **Constraints**
  - SQL prevents changes violating integrity constraints
  - Primary key
    - Must be non-null and unique
    - `PRIMARY KEY (A_j1, A_j2, ..., A_jn)`
  - Foreign key
    - Attribute values must match primary key values in relation s
    - `FOREIGN KEY (A_k1, A_k2, ..., A_kn) REFERENCES s`
  - Not null
    - Null value not allowed for attribute
    - A_i D_i NOT NULL

* Select

```sql 
SELECT A_1, A_2, ..., A_n 
    FROM r_1, r_2, ..., r_m 
    WHERE P; 
```
- `SELECT`: select the attributes to list (i.e., projection)
- `FROM`: list of tables to be accessed
  - Define a Cartesian product of the tables
  - The query is going to be optimized to avoid to enumerate tuples that will be
    eliminated
- `WHERE`: predicate involving attributes of the relations in the `FROM` clause
  (i.e., selection)
- In `SELECT` or `WHERE` clauses, might need to use the table names as prefix to
  qualify the attribute name
  - E.g., `instructor.ID` vs `teaches.ID`
- A `SELECT` statement can be expressed in terms of relational algebra
  - Cartesian product $\to$ selection $\to$ projection
  - Difference: SQL allows duplicate values, relational algebra works with
    mathematical sets

* Null values
- An arithmetic operation with `NULL` yields `NULL`
- Comparison with NULL
  - `1 < NULL`
  - `NOT(1 < NULL)`
  - SQL yields `UNKNOWN` when comparing with `NULL` value
  - There are 3 logical values: `True`, `False`, `Unknown`
- Boolean operators
  - Can be extended according to common sense, e.g.,
  - `True AND UNKNOWN = UNKNOWN`
  - `False AND Unknown = False`
- In a `WHERE` clause, if the result is `UNKNOWN` it's not included

* Group by Query
::: columns
:::: {.column width=65%}
- The attributes in `GROUP BY` are used to form groups
  - Tuples with the same value on all attributes are placed in one group
- Any attribute that is not in the `GROUP BY` can appear in the `SELECT` clause
  only as argument of aggregate function

\vspace{0.25cm}
```sql 
    SELECT dept_name, AVG(salary)
        FROM instructor 
        GROUP BY dept_name; 
```
\vspace{0.25cm}
```
    -- Error. 
```

```sql 
    SELECT dept_name, salary 
        FROM instructor 
        GROUP BY dept_name; 
```
\vspace{0.25cm}
- `salary` is not in `GROUP BY` so it must be in an aggregate function
::::
:::: {.column width=35%}

![](data605/lectures_source/images/lecture_4_1/lec_4_1_slide_20_image_1.png)
![](data605/lectures_source/images/lecture_4_1/lec_4_1_slide_20_image_2.png)

::::
:::

* Having
- State a condition that applies to groups instead of tuples (like WHERE)
- Any attribute in the HAVING clause must appear in the GROUP BY clause
- E.g., find departments with avg salary of instructors > 42k
  ```sql 
      SELECT dept_name, AVG(salary) AS avg_salary
          FROM instructor 
          GROUP BY dept_name 
          HAVING AVG(salary) > 42000; 
  ```

\vspace{0.5cm}

- How does it work
  - FROM is evaluated to create a relation
  - (optional) WHERE is used to filter
  - GROUP BY collects tuples into groups
  - (optional) HAVING is applied to each group and groups are filtered
  - SELECT generates tuples of the results, applying aggregate functions to get a single result for each group

* Nested subqueries
- SQL allows using the result of a query in another query
  - Use a subquery returning one attribute (scalar subquery) where a value is
    used
  - Use the result of a query for set membership in the WHERE clause
  - Use the result of a query in a FROM clause

:::columns
::::{.column width=60%}  
```sql 
SELECT tmp.dept_name, tmp.avg_salary 
  FROM (
    SELECT dept_name, 
        AVG(salary) AS avg_salary 
    FROM instructor 
    GROUP BY dept_name) AS tmp
WHERE avg_salary > 42000 
```
::::
::::{.column width=40%}  

![](data605/lectures_source/images/lecture_4_1/lec_4_1_slide_22_image_1.png)
::::
:::

* With
- `WITH` clause allows to define a temporary relation containing the results of a
  subquery
- It can be equivalent to a nested subqueries, but clearer

- E.g., find department with the maximum budget
  :::columns
  ::::{.column width=80%}  
  ```sql
  WITH max_budget(value) as (
    SELECT MAX(budget) FROM department) 
    SELECT department.dept_name, budget 
      FROM department, max_budget 
      WHERE department.budget = max_budget.value 
  ```
::::
::::{.column width=20%}  
![](data605/lectures_source/images/lecture_4_1/lec_4_1_slide_23_image_1.png)
::::
:::

* Insert
- To insert data into a relation we can specify tuples to insert
  - Tuples
  \begingroup
  \footnotesize
  ```sql
      INSERT INTO course VALUES ('DATA-605', 'Big data systems', 'Comp. Sci.', 3)
      INSERT INTO course(course_id, title, dept_name, credits)
          VALUES ('DATA-605', 'Big data systems', 'Comp. Sci.', 3)
  ```
  \endgroup

  - Query whose results is a set of tuples
  ```sql
      INSERT INTO instructor
          (SELECT ID, name, dept_name, 18000
          FROM student
          WHERE dept_name = 'Music' AND tot_cred > 144)
  ```

  - Nested queries are evaluated and then inserted so this doesn't create infinite loops
    ```sql
      INSERT INTO student (SELECT * FROM student)
    ```
  - Many DB have bulk loader utilities to insert a large set of tuples into a
    relation, reading from formatted text files 
  This is much faster than INSERT statements

* Update
- SQL can change a value in a tuple without changing all the other values
- E.g., increase salary of all instructors by 5%
  ```sql
  UPDATE instructor SET salary = salary * 1.05
  ```
- E.g., conditionally
  ```sql
  UPDATE instructor SET salary = salary * 1.05
      WHERE salary < 70000
  ```
- Nesting is allowed
  ```sql
  UPDATE instructor SET salary = salary * 1.05
      WHERE salary < (SELECT AVG(salary) FROM instructor)
  ```

* Delete
- One can delete tuples using a query returning entire rows of a table
  ```sql
  DELETE FROM r WHERE p
  ```
  where:
  - r is a relation
  - P is a predicate
- Remove all tuples (but not the table)
  ```sql
  DELETE FROM instructor
  ```

* SQL Tutorial

:::columns
::::{.column width=60%}
- SQL tutorial dir
- Readme**
**
  - Explains how to run the tutorial
- Three notebooks in tutorial\_university
- **How to learn from a tutorial
**
  - Reset the notebook
  - Execute each cell one at the time
  - Ideally create a new file and retype (!) everything
  - Understand what each cell does
  - Look at the output
  - Change the code
  - Play with it
  - Build your mental model
::::
::::{.column width=40%}

![](data605/lectures_source/images/lecture_4_1/lec_4_1_slide_27_image_1.png)
::::
:::

## Movie Database Example (Optional)

* Example Schema for SQL Queries

\footnotesize
```schema
Movie(title, year, length, inColor, studioName, producerC\#)
StarsIn(movieTitle, movieYear, starName)
MovieStar(name, address, gender, birthdate)
MovieExec(name, address, cert\#, netWorth)
Studio(name, address, presC\#)
```

![](data605/lectures_source/images/lecture_4_1/lec_4_1_slide_29_image_1.png){width=70%}

* SQL: Data Definition
- CREATE TABLE

```sql
    CREATE TABLE movieExec (
        name char(30),
        address char(100),
        cert# integer primary key,
        networth integer);

    CREATE TABLE movie (
        title char(100),
        year integer,
        length integer,
        inColor smallint,
        studioName char(20),
        producerC# integer references
            movieExec(cert#) );
```
- Must define movieExec before movie. Why?

* SQL: Data Manipulation
- INSERT
  ```sql
      INSERT INTO StarsIn values('King Kong', 2005, 'Naomi Watts');
  ```
  ```sql
      INSERT INTO StarsIn(starName, movieTitle, movieYear)
          values('Naomi Watts', 'King Kong', 2005);
  ```
- DELETE
  ```sql
      DELETE FROM movies WHERE movieYear < 1980;
  ```
  - Syntax is fine, but this command will be rejected. Why?
  ```sql
      DELETE FROM movies
          WHERE length < (SELECT avg(length) FROM movies);
  ```
  - Problem: as we delete tuples, the average length changes
  - Solution:
    - First, compute avg length and find all tuples to delete
    - Next, delete all tuples found above (without recomputing avg or retesting the tuples)

* SQL: Data Manipulation
- UPDATE
  - Increase all movieExec netWorth's over 100,000 USD by 6%, all other accounts receive 5%
  - Write two update statements:
  ```sql
      UPDATE movieExec SET netWorth = netWorth * 1.06
          WHERE netWorth > 100000;
  ```
  ```sql
      UPDATE movieExec SET netWorth = netWorth * 1.05
          WHERE netWorth <= 100000;
  ```
  - The order is important
  - Can be done better using the case statement
  ```sql
      UPDATE movieExec SET netWorth =
          CASE
              WHEN netWorth > 100000 THEN netWorth * 1.06
              WHEN netWorth <= 100000 THEN netWorth * 1.05
          END;
  ```

* SQL Single Table Queries
- Movies produced by Disney in 1990: note the *rename*
  ```sql
      SELECT m.title, m.year
          FROM movie m
          WHERE m.studioname = 'disney' AND m.year = 1990;
  ```
  - The SELECT clause can contain expressions
  ```sql
      SELECT title || ' (' || to_char(year) || ')' AS titleyear
  ```
  ```sql
      SELECT 2014 - year
  ```
  - The WHERE clause support a large number of different predicates and combinations thereof
  ```sql
      year BETWEEN 1990 and 1995
  ```
  ```sql
      title LIKE 'star wars%'
  ```
  ```sql
      title LIKE 'star wars _'
  ```

* Single Table Queries
- Find distinct movies sorted by title
  ```sql
      SELECT DISTINCT title
          FROM movie
          WHERE studioname = 'disney' AND year = 1990
          ORDER by title;
  ```
- Average length of a movie
  ```sql
      SELECT year, avg(length)
          FROM movie
          GROUP BY year;
  ``` 
- **GROUP BY:** is a very important concept that shows up in many data processing platforms
  - What it does:
    - Partition the tuples by the group attributes (*year* in this case)
    - Do something (*compute avg* in this case) for each group
    - Number of resulting tuples == number of groups

* Single Table Queries
- Find movie with the maximum length
  ```sql
      SELECT title, year
          FROM movie
          WHERE movie.length = (SELECT max(length) FROM movie);
  ```
  - The smaller "subquery" is called a "nested subquery"
- Find movies with at most 5 stars: an example of a correlated subquery
  ```sql
      SELECT *
          FROM movies m
          WHERE 5 >= (SELECT count(*)
                      FROM starsIn si
                      WHERE si.title = m.title AND
                            si.year = m.year);
  ```
  - The "inner" subquery counts the number of actors for that movie.

* Single Table Queries
- Rank movies by their length
  ```sql
      SELECT title, year,
          (SELECT count(*)
          FROM movies m2
          WHERE m1.length <= m2.length) AS rank
          FROM movies m1;
  ```
  - Key insight: A movie is ranked 5th if there are exactly 4 movies with longer length.
  - Most database systems support some sort of a *rank* keyword for doing this
  - The above query doesn't work in presence of ties, etc.
- Set operations
  ```sql
      SELECT name
          FROM movieExec
      union/intersect/minus
          SELECT name FROM
              movieStar
  ```

* Single Table Queries
- Set Comparisons
  ```sql
  SELECT *
      FROM movies
      WHERE year IN [1990, 1995, 2000];
  ```
  ```sql
  SELECT *
      FROM movies
      WHERE year NOT IN (
          SELECT EXTRACT(year from birthdate)
          FROM MovieStar
      );
  ```

* Multi-table Queries
- Key:
  - Do a join to get an appropriate table
  - Use the constructs for single-table queries
  - You will get used to doing all at once
- Examples:
  ```sql
      SELECT title, year, me.name AS producerName
          FROM movies m, movieexec me
          WHERE m.producerC# = me.cert#;
  ```

* Multi-table Queries
- Consider the query:
  ```sql
      SELECT title, year, producerC#, count(starName)
          FROM movies, starsIn
          WHERE title = starsIn.movieTitle AND
                year = starsIn.movieYear
          GROUP BY title, year, producerC#
  ```

  - What about movies with no stars?
  - Need to use **outer joins**
  ```sql
      SELECT title, year, producerC#, count(starName)
          FROM movies LEFT OUTER JOIN starsIn
          ON title = starsIn.movieTitle AND year = starsIn.movieYear
          GROUP BY title, year, producerC#
  ```

  - All tuples from 'movies' that have no matches in starsIn are included with NULLs
  - So if a tuple (m1, 1990) has no match in starsIn, we get (m1, 1990, NULL) in
    the result
  - The count(starName) works correctly then
  - Note: count(*) would not work correctly (NULLs can have unintuitive behavior)

* Other SQL Constructs
- Views
  ```sql
    CREATE VIEW DisneyMovies
        SELECT *
            FROM movie m
            WHERE m.studioname = 'disney';
  ```

  - Can use it in any place where a table name is used
  - Views are used quite extensively to:
    - simplify queries
    - hide data (by giving users access only to specific views)
  - Views may be *materialized *or not

* Other SQL Constructs
- NULLs
  - Value of any attribute can be NULL
  - Because: value is unknown, or it is not applicable, or hidden, etc.
  - Can lead to counterintuitive behavior
  - For example, the following query does not return movies where length = NULL
  ```sql
        SELECT * FROM movies 
        WHERE length >= 120 OR length <= 120
  ```
  - Aggregate operations can be especially tricky
- Transactions
  - A transaction is a sequence of queries and update statements executed as a single unit
  - For example, transferring money from one account to another
    - Both the *deduction* from one account and *credit* to the other account should happen, or neither should
- Triggers
  - A trigger is a statement that is executed automatically by the system as a side effect of a modification to the database

* Other SQL Constructs
- Integrity Constraints
  - Predicates on the database that must always hold
  - Key Constraints: Specifying something is a primary key or unique
  ```sql
      CREATE TABLE customer (
          ssn CHAR(9) PRIMARY KEY,
          cname CHAR(15),
          address CHAR(30),
          city CHAR(10),
      UNIQUE (cname, address, city));
  ```
  - Attribute constraints: Constraints on the values of attributes
  ```sql
  bname char(15) not null
  ```
  ```sql
  balance int not null, check (balance>= 0)
  ```

* Integrity Constraints
- Referential integrity: prevent dangling tuples
  ```sql
    CREATE TABLE branch(bname CHAR(15) PRIMARY KEY, ...);
    CREATE TABLE loan(..., FOREIGN KEY bname REFERENCES branch);
  ```
- Can tell the system what to do if a referenced tuple is being deleted

* Integrity Constraints
- Global Constraints
  - Single-table
    ```sql
      CREATE TABLE branch (..., bcity CHAR(15), assets INT,
          CHECK (NOT(bcity = 'Bkln') OR assets>5M))
    ```
  - Multi-table
    ```sql
      CREATE ASSERTION loan-constraint 
      CHECK (NOT EXISTS
          (SELECT* FROM loan AS L WHERE NOT EXISTS
              (SELECT* FROM borrower B, depositor D, account A
              WHERE B.cname = D.cname AND D.acct_no = A.acct_no
                  AND L.lno= B.lno)))
    ```

* Additional SQL Constructs
- `SELECT` subquery factoring
  - To allow assigning a name to a subquery, then use its result by referencing
    that name
    ```sql
      WITH temp AS (
          SELECT title, avg(length)
          FROM movies
          GROUP BY year)
      SELECT COUNT(*) FROM temp;
    ```
  - Can have multiple subqueries (multiple with clauses)
  - Real advantage is when subquery needs to be referenced multiple times in main
    select
  - Helps with complex queries, both for readability and maybe performance (can
    cache subquery results)

* Another SQL Construct
- `SELECT HAVING` clause
  - Used in combination with `GROUP BY` to restrict the groups of returned rows
    to only those where condition evaluates to true
  ```sql
    SELECT year, count(*)
        FROM movies
        WHERE year > 1980
        GROUP BY year
        HAVING COUNT(*) > 10;
  ```
  - Difference from `WHERE` clause is that it applies to summarized group
    records, and where applies to individual records

