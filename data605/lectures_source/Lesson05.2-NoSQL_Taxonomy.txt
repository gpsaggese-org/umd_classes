// Dir is https://drive.google.com/drive/folders/1u8ZUAkLc8yZBwGgXvfBcAY_oSCyzT_pp

::: columns
:::: {.column width=15%}
![](msml610/lectures_source/figures/UMD_Logo.png)
::::
:::: {.column width=75%}

\vspace{0.4cm}
\begingroup \large
UMD DATA605 - Big Data Systems
\endgroup
::::
:::

\vspace{1cm}

\begingroup \Large
**$$\text{\blue{NoSQL Taxonomy}}$$**
\endgroup

::: columns
:::: {.column width=75%}
\vspace{1cm}

**Instructor**: Dr. GP Saggese - [](gsaggese@umd.edu)

- Concepts in slides

- Silberschatz Chapter 23.6

- High-level view:
  - Seven Databases in Seven Weeks, 2e

::::
:::: {.column width=20%}

![](data605/lectures_source/images/lecture_5_0/lec_5_0_slide_4_image_1.png)

::::
:::

* DB Taxonomy
:::columns
::::{.column width=50%}

- **At least five DB genres**
  - _Relational_ (e.g., Postgres)
  - _Key-value_ (e.g., Redis)
  - _Document_ (e.g., MongoDB)
  - _Columnar_ (e.g., Parquet)
  - _Graph_ (e.g., Neo4j)
::::
::::{.column width=25%}
![](data605/lectures_source/images/lecture_5_0/lec_5_0_slide_24_image_3.png){width=80%}
::::
::::{.column width=25%}
![](data605/lectures_source/images/lecture_5_0/lec_5_0_slide_24_image_2.png){width=80%}
::::
:::
\vspace{1cm}
:::columns
::::{.column width=50%}

- **Criteria to differentiate DBs**
  - Data model
  - Trade-off with CAP theorem
  - Querying capability
  - Replication scheme
::::
::::{.column width=25%}
![](data605/lectures_source/images/lecture_5_0/lec_5_0_slide_24_image_4.png){width=80%}
::::
::::{.column width=25%}
![](data605/lectures_source/images/lecture_5_0/lec_5_0_slide_24_image_1.png){width=80%}
::::
:::

* Relational DB

- E.g., _Postgres_, MySQL, Oracle, SQLite

- **Data model**
  - Set-theory, relational algebra
  - Data as tables with rows, columns
  - Many attribute types (e.g., numeric, strings, dates, arrays, blobs)
  - Strictly enforced attribute types
  - SQL query language
  - ACID consistency

- **Application**
  - Relational tabular data

- **Good for**
  - Known data layout, unknown access pattern
  - Schema complexity for query flexibility
  - Regular data

- **Not so good for**
  - Hierarchical data (not a nice row in tables)
  - Variable/dishomogeneous data (record-to-record variation)

* Key-Value Store
:::columns
::::{.column width=75%}

- E.g., redis, DynamoDB, Git, AWS S3, filesystem

- **Data model**
  - Map keys (e.g., strings) to complex values (e.g., binary blob)
  - Support get, put, delete operations on a primary key

- **Application**
  - Caching data
  - Store users' session data in web applications
  - Store shopping carts in e-commerce applications

- **Good for**
  - Data not "related" (e.g., no joins)
  - Fast lookups
  - Easy to scale horizontally using partitioning

- **Not so good for**
  - Data queries needed
  - Lacking secondary indexes and scanning
::::
::::{.column width=25%}
![](data605/lectures_source/images/lecture_5_0/lec_5_0_slide_26_image_1.png)
::::
:::

* Document Store
:::columns
::::{.column width=75%}

- E.g., _MongoDB_, CouchDB

- **Data model**
  - Like key-value but value is a document (nested dict)
  - Each document has a unique ID (e.g., hash)
  - Any number of fields per document, even nested
    - E.g., jSON, XML, dict data

- **Application**
  - Semi-structured data

- **Good for**
  - Unknown data structure
  - Maps well to OOP models (less impedance mismatch)
  - Easy to shard and replicate over distributed servers

- **Not so good for**
  - Complex join queries
  - Denormalized form is the norm
::::
::::{.column width=25%}
![](data605/lectures_source/images/lecture_5_0/lec_5_0_slide_27_image_1.png)
::::
:::

* Columnar Store
:::columns
::::{.column width=80%}

- E.g., _HBase_, Cassandra, _Parquet_

- **Data model**
  - Store data by columns, not rows
  - Similar to key-value and relational DBs
    - Use keys to query values
    - Values are groups of columns

- **Application**
  - Store web pages
  - Store time series data
  - OLAP workloads

- **Good for**
  - Horizontal scalability
  - Enable compression and versioning
  - Sparse tables without extra storage cost
  - Inexpensive to add columns

- **Not so good for**
  - Design schema based on query plans
  - No native joins; applications handle joins
::::
::::{.column width=20%}
![](data605/lectures_source/images/lecture_5_0/lec_5_0_slide_28_image_1.png)
::::
:::

* Graph DB
:::columns
::::{.column width=80%}

- E.g., _Neo4J_, GraphX

- **Data model**
  - Interconnected data, nodes, and relationships
  - Nodes and edges have properties (key-value pairs)
  - Queries traverse nodes and relationships

- **Applications**
  - Social data
  - Recommendation engines
  - Geographical data

- **Good for**
  - Networked data, difficult to model with relational model
  - Matches OO systems

- **Not so good for**
  - Poor scalability, difficult to partition graph on different nodes
    - Store graph in graph DB, relations in key-value store
::::
::::{.column width=20%}
![](data605/lectures_source/images/lecture_5_0/lec_5_0_slide_29_image_1.png)
::::
:::

* Taxonomy by CAP
\centering
![](data605/lectures_source/images/lecture_5_0/lec_5_0_slide_30_image_1.png){width=80%}
From http://blog.nahurst.com/visual-guide-to-nosql-systems

* Taxonomy by CAP
:::columns
::::{.column width=60%}

- **CA (Consistent, Available) systems**
  - Struggle with partitions, use replication
  - Traditional RDBMSs (e.g., PostgreSQL, MySQL)

- **CP (Consistent, Partition-Tolerant) systems**
  - Struggle with availability, maintain consistency across partitions
  - BigTable (column-oriented/tabular)
  - HBase (column-oriented/tabular)
  - MongoDB (document-oriented)
  - Redis (key-value)
  - MemcacheDB (key-value)
  - Berkeley DB (key-value)
::::
::::{.column width=40%}
\vspace{1cm}
![](data605/lectures_source/images/lecture_5_0/lec_5_0_slide_31_image_1.png)
::::
:::

- **AP (Available, Partition-Tolerant) systems**
  - Achieve "eventual consistency" via replication and verification
  - Dynamo (key-value)
  - Cassandra (column-oriented/tabular)
  - CouchDB (document-oriented)
