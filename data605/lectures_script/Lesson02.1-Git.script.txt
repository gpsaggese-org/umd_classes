# ##############################################################################
# Bash / Linux: Resources
# ##############################################################################

- The command line is a powerful tool for interacting with your computer
  - Beginners can find a helpful online tutorial pointed here covering the basics
  - You should know how to use `find` for file searches, `xargs` for executing
    command lines from input, `chmod` and `chown` for file permissions and
    ownership, and understand symbolic and hard links for file referencing
- Understanding Linux is essential
  - This includes knowing how processes work, managing file ownership and
    permissions, and understanding virtual memory. Administering a Linux system
    as the root user is also beneficial
- For advanced Linux command line skills, a comprehensive online resource is
  available to guide you through more complex topics and enhance proficiency

Now, let's move on to resources for Git, a popular version control system.

# ##############################################################################
# Git Resources
# ##############################################################################

- As always all concepts are in the slides

- Tutorial: There is a Git tutorial available online that can help you get
  started with using Git effectively.

- We will use Git during the project: Git will be an integral part of the
  project work, so familiarity with it is important.

- For those seeking to master Git, there is a free book available online that
  covers Git in depth.

- There are several online resources that provide additional guidance on using
  Git, including interactive tutorials and troubleshooting guides.
- There are also interactive platforms where you can practice Git commands and
  concepts in a safe environment.

Let's delve into the basics of version control systems and their importance.

# ##############################################################################
# Version Control Systems (1/2)
# ##############################################################################

- A Version Control System (VCS) is essential for managing changes to files over
  time. It allows you to record changes, recall specific versions, compare
  changes, and track who made changes, when, and why. This is like having a
  "file time-machine" that helps you manage your work efficiently.

- Simplest "VCS": The simplest form of version control is manually copying
  directories and adding version numbers or timestamps. While this method can
  work for a single person, it doesn't scale well for collaborative work or
  larger projects.

# ##############################################################################
# Version Control Systems (2/2)
# ##############################################################################

In this slide, we explore two types of version control systems (VCS):
centralized and distributed. Centralized VCS, like Perforce and Subversion, rely
on a central server to store code. Clients connect to this server to access and
update the code. A major downside is that if the server goes down, no one can
work, which can be a significant bottleneck in development processes. On the
other hand, distributed VCS, such as Git, Mercurial, Bazaar, and Dart, allow
each client to have the entire history of the repository locally. This means
each node acts as both a client and a server, providing more flexibility and
resilience. However, distributed systems can be complex to manage due to the
decentralized nature of the data.

# ##############################################################################
# VCS: How to Track Data
# ##############################################################################

Transitioning from the types of VCS, we now focus on how these systems track
changes to data. When managing a directory with project files, it's crucial to
track changes effectively. Delta-based VCS, like Subversion, store data as
patches, which are changes made to files over time. This method allows the
reconstruction of the repository's state by applying these patches sequentially.
In contrast, stream of snapshots VCS, such as Git, store data as snapshots of
the filesystem. This approach involves taking a "picture" of the files at a
given time, storing a reference (hash) to these snapshots, and linking to
previous identical files. This method can be more efficient as it avoids storing
redundant data.

# ##############################################################################
# Git
# ##############################################################################

Git is a powerful tool because almost everything is done locally. The history of
changes is stored on each node, and file differences are calculated locally,
unlike centralized VCS that require server access for these operations. You can
commit changes to your local copy and upload them when you have a network
connection. Another advantage of Git is that almost everything is undoable,
meaning you can recover from mistakes without data corruption, as everything is
checksummed. However, it's important to commit or stash changes properly to
avoid issues. Git functions as a mini key-value store with a VCS built on top,
consisting of two layers: the "porcelain" layer, which acts as a key-value store
for the filesystem, and the "plumbing" layer, which is the VCS layer.

# ##############################################################################
# Sections of a Git Project
# ##############################################################################

In a Git project, there are three main sections that you need to understand.
First, the working tree, also known as the checkout, is the version of your code
that you have on your computer's filesystem. This is where you can make changes
and work on your code. Next is the staging area, sometimes called the cache or
index. This is a special file in the .git directory that stores information
about what will be included in your next commit. Finally, the Git directory,
often referred to as .git, is like a database that holds all the metadata and
objects related to your project. This is essentially the repository itself,
containing the entire history of your project. When you clone a project, you are
essentially copying this .git directory to your local machine.

Let's move on to understand the different states a file can be in within a Git
project.

# ##############################################################################
# States of a File in Git
# ##############################################################################

In Git, each file can be in one of four states. First, a file can be untracked,
meaning it is not yet under Git's version control. This usually happens when you
create a new file but haven't told Git to track it yet. A file can also be
modified, which means you've made changes to it, but those changes haven't been
saved in a commit. When you stage a file, you are marking it for inclusion in
the next commit. Finally, a committed file is one where the data has been stored
in the local database, making it a permanent part of your project's history.

Now, let's discuss how you can effectively learn and use Git through tutorials.

# ##############################################################################
# Git Tutorial
# ##############################################################################

To get started with Git, it's recommended to follow a Git tutorial available in
your class repository. Begin by carefully reading the README file. When using a
tutorial, type each command manually instead of copying and pasting. This helps
you understand what each command does. Pay attention to the results of each
command to ensure they match your expectations. Experiment with different
commands to see how they affect your project. It's important to learn how to use
Git from the command line before relying on graphical user interfaces, as GUIs
can hide important details. Additionally, go through a recommended Git book and
try out all the examples. Online tutorials can also be helpful. Create your own
cheat sheet to remember important commands, but only reuse others' cheat sheets
if you are already familiar with the content. Finally, aim to master basic tools
like Bash, Git, and a text editor, as well as programming languages like Python
and libraries like Pandas.

With this foundation, you'll be well-equipped to manage your projects using Git.

# ##############################################################################
# Git: Daily Use
# ##############################################################################

In this slide, we are introduced to the basic daily operations of using Git, a
version control system. When starting with a Git project, you either clone an
existing project using `git clone` or initialize a new one with `git init`. This
step is done only once per project on your local machine. The daily routine
involves modifying files in your working directory, which can be done using any
text editor like `vi`. Once changes are made, you add these files to the staging
area using `git add`. To stage all changes, you can use `git add -u`. After
staging, you commit these changes to the local repository with `git commit`.

Using branches is crucial for organizing your work. A branch allows you to
isolate your code changes from the main codebase, often referred to as `master`.
You can merge changes from `master` into your branch to keep it updated. Once
your work is ready, you create a Pull Request (PR) for code review. After
approval, the PR is merged back into the main codebase. This process helps in
maintaining a clean and organized project history.

Transitioning to the next slide, let's explore how Git handles remote
repositories and collaboration.

# ##############################################################################
# Git Remote
# ##############################################################################

This slide focuses on the concept of remote repositories in Git, which are
versions of your project hosted online. Managing remote repositories is
essential for collaboration, as it allows multiple people to work on the same
project. You can push your local changes to a remote repository or pull changes
from it. The command `git remote -v` shows the remote repositories linked to
your local project. To update your local repository with changes from the
remote, use `git fetch`. The `git pull` command is a combination of fetching and
merging changes from the remote into your local branch. To share your changes,
you use `git push <REMOTE> <BRANCH>`, for example, `git push origin master`.

When working with remote repositories, there might be multiple forks with
different access policies, such as read-only or read-write. If someone else has
pushed changes to the remote, you cannot push your changes immediately. You need
to fetch the latest changes, merge them into your branch, resolve any conflicts,
and test the project to ensure everything works correctly before pushing your
changes.

Now, let's move on to understanding how Git tagging works.

# ##############################################################################
# Git Tagging
# ##############################################################################

In this slide, we learn about Git tagging, a feature that allows you to mark
specific points in your project's history with a tag. Tags are often used to
mark release points, making it easier to identify and check out specific
versions of your project. When you check out a tag, you enter a detached `HEAD`
state. This means that any commits you make will not be added to the tag or any
branch. Instead, these commits will be "unreachable" and can only be accessed by
their commit hash.

Tagging is useful for creating snapshots of your project at significant
milestones, such as version releases. It helps in maintaining a clear and
organized project history, making it easier to track changes and revert to
previous versions if needed. However, it's important to note that while in a
detached `HEAD` state, any new commits won't be part of the main project history
unless you explicitly create a new branch from that state.

With this understanding of Git tagging, you are now equipped with the basic
knowledge to manage your project's history effectively.

# ##############################################################################
# Git Internals
# ##############################################################################

Understanding Git requires a grasp of its data model, which functions as a
key-value store with a version control system interface. In this model, the key
is the hash of a file, and the value is the file's content. Git objects are
fundamental to this model and include commits, trees, and blobs. Commits act as
pointers to the tree and contain commit metadata. Trees represent directories
and map files to blobs, which hold the actual content of files. For those
looking to delve deeper, there are resources available ranging from easy to
hard-core, such as articles on understanding the Git data model and Git
internals. Visual aids like commit trees, commit parents, and commit history of
a branch can help in visualizing these concepts. These images illustrate how
commits are structured and how they relate to each other, providing a clearer
picture of Git's internal workings.

Transitioning to the next slide, let's explore how branching in Git enhances
development workflows.

# ##############################################################################
# Git Branching
# ##############################################################################

Branching in Git allows developers to diverge from the main development line,
enabling them to work on features or fixes without affecting the main codebase.
This is crucial for avoiding unwanted changes in the main branch and for merging
updates downstream or upstream as needed. Git's branching is lightweight and
instantaneous, with branches acting as pointers to commits. Unlike some other
version control systems, Git stores data as snapshots rather than file
differences, making branching and merging frequent and efficient. This might be
surprising for users of distributed version control systems, but in Git,
branches are cheap and can be used to isolate and organize work effectively.
Developers are encouraged to branch and merge often, even multiple times a day,
to maintain a smooth workflow.

Now, let's delve deeper into the specifics of Git branching and how it operates
within the system.

# ##############################################################################
# Git Branching
# ##############################################################################

In Git, the `master` or `main` branch is a regular branch that points to the
last commit and moves forward with each new commit. The `HEAD` is a pointer to
the local branch, such as `master` or `testing`, and using
`git checkout <BRANCH>` allows you to switch between branches. Creating a new
branch, like `git branch testing`, establishes a new pointer that points to the
current commit and can be moved as needed. This setup allows for divergent
history, where work can progress in two separate branches, enabling parallel
development. Visual representations of these concepts, such as diagrams showing
branch pointers and divergent histories, can help in understanding how branches
operate and interact within Git. These images illustrate the dynamic nature of
branches and how they facilitate concurrent development efforts.

With this understanding of Git branching, you can better manage and organize
your development projects.

# ##############################################################################
# Git Checkout
# ##############################################################################

- Git checkout is a command used to switch between different branches in a
  repository. When you execute this command, it moves the HEAD pointer to the
  branch you want to work on. This means that the files in your working
  directory will change to match the state of the branch you have switched to.
  For example, if you have two branches named master and testing, and you are
  currently on the master branch, you can switch to the testing branch by using
  the command git checkout testing. This action will move the pointer to the
  testing branch, and the files in your working directory will update to reflect
  the changes in the testing branch. Once you are on the testing branch, you can
  continue working and make commits. As you commit changes, the pointer for the
  testing branch will move forward to include your new commits. This process
  allows you to work on different features or fixes in isolation without
  affecting the main branch until you are ready to merge your changes.

Let's move on to how branching and merging work in Git.

# ##############################################################################
# Git Branching and Merging
# ##############################################################################

- Git branching and merging are essential concepts for managing changes in a
  project. Tutorials are available to guide you through working on the main
  branch and handling hotfixes. When you start from a project with some existing
  commits, you can create a new branch to work on a specific feature or issue.
  For instance, if you need to address "Issue 53," you can create a new branch
  using the command git checkout -b iss53. This command creates and switches to
  a new branch named iss53, allowing you to work on the issue independently. As
  you make progress, you can commit your changes to the iss53 branch. This
  approach helps keep your work organized and separate from the main branch,
  making it easier to manage and review changes before merging them back into
  the main branch.

Now, let's discuss how to handle hotfixes and divergent histories in Git.

# ##############################################################################
# Git Branching and Merging
# ##############################################################################

- Sometimes, you may need to apply a hotfix directly to the master branch. To do
  this, you can switch to the master branch using git checkout master and then
  create a new branch for the hotfix with git checkout -b hotfix. After making
  the necessary fixes, you can commit the changes with git commit -am "Hot fix".
  Once the hotfix is complete, you can merge it back into the master branch
  using git merge hotfix. This process ensures that critical fixes are applied
  quickly and efficiently. Additionally, when working with branches, you may
  encounter a situation where there is a divergent history between branches,
  such as between master and iss53. In such cases, Git can perform a fast
  forward merge if there are no conflicting changes. This type of merge moves
  the pointer of the master branch forward to include the changes from the iss53
  branch, effectively integrating the new feature or fix into the main branch
  without creating a new commit.

With these concepts in mind, you can effectively manage branches and merges in
your Git workflow.

# ##############################################################################
# Git Branching and Merging
# ##############################################################################

When working with Git, you often create branches to work on specific features or
fixes. In this example, you are working on a branch called `iss53`. As you make
changes, this branch diverges from the main branch, often called `master`. Once
you finish your work on `iss53`, you need to merge it back into `master`. To do
this, you switch to the `master` branch using `git checkout master` and then
merge the changes from `iss53` with `git merge iss53`. Sometimes, Git cannot
perform a fast-forward merge, which means the branches have diverged too much.
In such cases, Git creates a new snapshot called a "merge commit," which
combines the changes from both branches. After merging, you can delete the
`iss53` branch with `git branch -d iss53` to keep your repository clean.

# ##############################################################################
# Fast Forward Merge
# ##############################################################################

A fast-forward merge is a simpler type of merge in Git. It happens when the
branch you want to merge has not diverged from the main branch. In this
scenario, Git can simply move the branch pointer forward to include the new
commits. Think of a branch as a pointer indicating the latest commit. For
example, if you have a commit `C3` and a new commit `C4'` is added, Git can move
the pointer from `C3` to `C4'` without creating a new merge commit. This is done
by checking out the `master` branch and merging the changes from another branch,
like `experiment`, using `git merge experiment`. This process is straightforward
and keeps the commit history linear.

Now, let's explore what happens when Git encounters conflicts during merging.

# ##############################################################################
# Merging Conflicts
# ##############################################################################

Sometimes, when merging branches in Git, conflicts arise. This happens when the
same file is modified in both branches or when a file is modified in one branch
and deleted in another. In such cases, Git cannot automatically merge the
changes and pauses the process to let you resolve the conflicts manually. Git
adds conflict resolution markers in the files to help you identify the
conflicting sections. To resolve these conflicts, you need to manually edit the
files using a text editor or an integrated development environment like PyCharm
or VS Code. After resolving the conflicts, you use `git add` to mark the files
as resolved and then `git commit` to complete the merge. Tools like
`git mergetool` can assist in this process by providing a visual interface for
conflict resolution. Understanding how to handle merge conflicts is crucial for
maintaining a smooth workflow in collaborative projects.

# ##############################################################################
# Git Rebasing
# ##############################################################################

In Git, there are two main ways to combine different branches of work: merging
and rebasing. When you have two branches, like `master` and `experiment`, that
share a common starting point, you can choose how to bring them together.
Merging involves switching to the target branch, such as `master`, and then
merging the changes from `experiment` into it. This creates a new commit that
represents the combined work. On the other hand, rebasing involves switching to
the branch you want to update, like `experiment`, and then applying its changes
on top of the latest state of the target branch, `master`. This process involves
taking all the changes made in `experiment` since the common ancestor, syncing
them with `master`, and then applying them. The result is that only the current
branch is affected, and the history appears linear, as if all changes happened
one after the other. This can make the project history cleaner and easier to
understand.

Now, let's explore the practical uses of rebasing in collaborative projects.

# ##############################################################################
# Uses of Rebase
# ##############################################################################

Rebasing is particularly useful for maintaining a clean project history. When
you rebase, the history appears as if all work was done in a straight line, even
though it might have been done in parallel. This can make it easier to follow
the project's development over time. For developers contributing to a project
they don't maintain, rebasing is a helpful tool. You can work on your branch
independently and, when ready, rebase your changes onto the main branch, like
`origin/master`. This way, the project maintainer doesn't have to deal with
complex integration work. They can simply fast forward or apply your changes
cleanly, without conflicts. This process streamlines collaboration and reduces
the chances of errors during integration.

Next, let's discuss the golden rule of rebasing and its implications.

# ##############################################################################
# Golden Rule of Rebasing
# ##############################################################################

Rebasing involves replacing existing commits with new ones that are similar but
different. This can cause issues if not handled carefully. If you push commits
to a remote repository and others base their work on them, rewriting those
commits with `git rebase` and then pushing them again with `git push --force`
can create problems. Collaborators will have to re-merge their work, which can
be time-consuming and error-prone. To avoid these issues, it's important to
follow the golden rule of rebasing. The strict approach is to never rebase
commits that have been shared outside your repository. The looser approach
allows you to rebase your branch if only you use it, even if it's been pushed to
a server. By following these guidelines, you can use rebasing effectively
without disrupting the work of others.

With these insights, you can now make informed decisions about when and how to
use rebasing in your projects.

# ##############################################################################
# Rebase vs Merge: Philosophical Considerations
# ##############################################################################

In this slide, we explore the philosophical debate between using rebase and
merge in version control systems like Git. The core question is about the
meaning of commit history in a repository. There are two main perspectives:

- Some believe that history should be an accurate record of what actually
  happened, even if it's messy. This approach advocates for using git merge,
  which preserves the original sequence of commits and reflects the true
  development process.

- Others argue that history should be presented in a way that is most beneficial
  for future readers. This perspective supports using git rebase and
  filter-branch to create a cleaner, more understandable history by rearranging
  and squashing commits.

The slide also humorously notes that many hours have been spent debating this
topic without reaching a consensus. Often, the decision is made based on the
preferences of the project maintainers. The slide suggests a balanced approach:
rebase changes in your local repository to keep your work tidy, but use git
merge when integrating changes into the master branch to preserve the
development history.

The speaker shares a personal preference for squashing and merging branches into
master, acknowledging that their commits are often just checkpoints rather than
complete features.

Now, let's move on to understanding remote branches and their significance in
collaborative projects.

# ##############################################################################
# Remote Branches
# ##############################################################################

This slide introduces the concept of remote branches in Git, which are pointers
to branches in remote repositories. Remote branches allow multiple developers to
collaborate on the same project by sharing code across different machines. The
command git remote -v is used to list the remote repositories associated with
your local repository.

Tracking branches are local references that represent the state of the remote
repository. For example, the local master branch might track the origin/master
branch on the remote repository. While you can't directly change a remote
branch, you can modify the tracking branch. Git updates these tracking branches
when you perform a git fetch origin or git pull.

To share code from a local branch, you need to push it to a remote repository
using a command like git push origin serverfix. If you want to work on a branch
that exists on the remote repository, you can create a local branch that tracks
it using git checkout -b serverfix origin/serverfix.

Understanding remote branches and tracking branches is crucial for effective
collaboration in a team setting. It ensures that everyone is working with the
latest code and can contribute their changes back to the shared repository.

# ##############################################################################
# Git Workflows
# ##############################################################################

In this slide, we are introduced to the concept of Git workflows, which are
essentially methods for working and collaborating using Git. The slide
highlights the importance of long-running branches, which are branches that
remain open and have varying levels of stability. The master branch is always
ready for release, ensuring that the code is stable and can be deployed at any
time. The develop branch is where active development takes place, allowing
developers to work on new features or improvements. Additionally, there are
topic or feature branches, which are used for specific tasks or features. Once
these branches reach a stable state, they are merged into the more stable
branches, like develop or master. This approach helps in maintaining a clean and
organized codebase, where the master branch is always in a releasable state.

# ##############################################################################
# Git Workflows
# ##############################################################################

Continuing with Git workflows, this slide focuses on topic branches, which are
short-lived branches created for a single feature or task. Examples include
branches named hotfix or wip-XYZ. These branches are easy to review and are
isolated from the rest of the codebase, allowing developers to work on specific
features without affecting the main code. This isolation is a strength of Git,
as other version control systems may not support branching as effectively. The
slide provides examples of how topic branches can be used, such as starting a
branch for a specific issue, making changes, and then creating a new version if
needed. It also highlights the importance of merging changes back into the main
branches, ensuring that the codebase remains up-to-date and stable.

Transitioning from Git workflows, let's explore how centralized workflows
function in both centralized version control systems and Git.

# ##############################################################################
# Centralized Workflow
# ##############################################################################

This slide explains the centralized workflow, which is common in centralized
version control systems (VCS). In this workflow, developers check out the code
from a central repository to their local machines, make modifications, and then
push the changes back to the central hub. If there are no conflicts with the
latest version, the changes are successfully integrated. However, if conflicts
arise, developers must resolve them before pushing their changes. In Git, the
centralized workflow is slightly different. Developers have write access to the
central repository, but they need to fetch the latest changes and merge them
with their local changes before pushing. Git prevents developers from
overwriting each other's code by only allowing fast-forward changes, which
ensures that the codebase remains consistent and conflict-free. This approach
helps maintain a stable and organized codebase, even when multiple developers
are working on the same project.

# ##############################################################################
# Forking Workflows
# ##############################################################################

In many projects, developers don't have the permission to directly update
branches. This is to maintain the integrity and stability of the project. Core
contributors have read-write permissions, while others have read-only access. To
allow contributions from external developers, a process called "forking" is
used. Forking involves creating a personal copy of the repository where
contributors can freely make changes. They clone the repository, create a branch
for their work, and push changes to their fork. Once ready, they prepare a pull
request (PR) to propose their changes to the main project. The project
maintainer reviews these PRs, decides whether to accept them, and integrates
them into the main project. This process ensures that only vetted and approved
changes are merged into the main codebase. This method is often referred to as
the "GitHub workflow," popularized by GitHub, which was acquired by Microsoft
for a significant sum, highlighting the importance of this workflow in modern
software development.

Now, let's explore another workflow model commonly used in open-source projects.

# ##############################################################################
# Integration-Manager Workflow
# ##############################################################################

The integration-manager workflow is a traditional model for open-source
development, used by projects like Linux. In this model, there is one official
repository managed by the project maintainer, who is the only one with
permission to push changes to the public repository. Contributors have read
access to this repository and can fork it into their own private copies. They
make changes in their forked repositories and push these changes to their public
copies. To propose their changes to the official project, contributors send a
pull request to the maintainer. The maintainer then adds the contributor's
repository as a remote, merges the changes into a local branch, tests them, and
if everything is satisfactory, pushes the changes to the official repository.
This workflow ensures that the project maintainer has control over what gets
included in the official project, maintaining quality and consistency.

Next, we will discuss how to track changes and commits using Git logs.

# ##############################################################################
# Git Log
# ##############################################################################

The `git log` command is a powerful tool for viewing the history of commits in a
repository. It provides detailed information about each commit, including the
author, date, and commit message. In Git, references or "refs" are pointers to
specific commits. Common refs include `HEAD`, which points to the current commit
you are working on, `origin/master`, which refers to the remote branch, and
local branches like `experiment`. Each commit has a unique identifier, such as
`d921970`. The caret symbol `^` is used to navigate through the commit history.
For example, `HEAD^` refers to the commit before the current `HEAD`, essentially
the last commit. The notation `^2` is equivalent to `^^`, indicating the second
parent of a merge commit, which can have multiple parents. Understanding these
references and how to navigate them is crucial for managing and reviewing
changes in a project effectively.

# ##############################################################################
# Dot Notation
# ##############################################################################

- Double-dot notation is a way to compare two branches in Git. When you use
  `1..2`, it shows you the commits that are in branch 2 but not in branch 1.
  Think of it as finding the difference between the two branches. For example,
  if you run `git log master..experiment`, it will list the commits `D` and `C`,
  which are in the experiment branch but not in the master branch. Conversely,
  `git log experiment..master` will show `F` and `E`, which are in the master
  branch but not in the experiment branch.

- Triple-dot notation, on the other hand, is used to find commits that are in
  either of the two branches but not in both. It's like a union of the two
  branches, excluding the intersection. When you use `1...2`, it lists all the
  commits that are unique to each branch. For instance,
  `git log master...experiment` will show `F`, `E`, `D`, and `C`, which are the
  commits that are not common to both branches.

Now, let's delve into some advanced Git features that can enhance your workflow.

# ##############################################################################
# Advanced Git
# ##############################################################################

- Stashing is a handy feature in Git that allows you to save the current state
  of your working directory, including modified and staged files, without
  committing them. This saved state is stored in a stack, which you can apply
  later when needed. It's useful when you need to switch branches but aren't
  ready to commit your changes.

- Cherry-picking is a way to apply a single commit from one branch onto another.
  It's like rebasing, but for just one commit. This is useful when you want to
  apply a specific change without merging the entire branch.

- Rerere, which stands for "Reuse Recorded Resolution," is a feature in Git that
  remembers how you resolved certain conflicts. This can save time if you
  encounter the same conflict again, as Git can automatically apply the previous
  resolution.

- Submodules and subtrees allow you to include other Git projects within your
  project. Submodules are like pointers to other repositories, while subtrees
  integrate the external project directly into your repository.

Let's continue exploring more advanced Git functionalities that can help in
managing your codebase effectively.

# ##############################################################################
# Advanced Git
# ##############################################################################

- The bisect command is a powerful tool for finding the exact commit where a bug
  was introduced. When a bug appears at the top of the tree and you don't know
  when it started, `git bisect` helps you pinpoint the problematic commit. It
  uses a binary search approach, where you mark commits as good or bad, and it
  narrows down to the commit where the change occurred.

- Filter-branch is used to rewrite the history of a repository in a scriptable
  way. This can be useful for tasks like changing an email address in commit
  history or removing a sensitive file. It checks out each version of the
  repository, runs a command, and commits the result, effectively rewriting the
  history.

- Hooks in Git are scripts that run automatically at certain points in the Git
  workflow, such as before a commit or merging. They can be used to enforce
  policies, run tests, or automate tasks, ensuring that certain conditions are
  met before changes are made to the repository.

# ##############################################################################
# Github
# ##############################################################################

GitHub is a major platform for hosting and collaborating on software projects.
In 2018, Microsoft acquired GitHub for $7.5 billion, highlighting its importance
in the tech industry. GitHub is the largest host for Git repositories, with over
100 million open-source projects. It offers a range of features that facilitate
software development and collaboration. These include pull requests (PRs) for
proposing changes, forks for creating personal copies of projects, issue
tracking for managing bugs and tasks, and code review for improving code
quality. GitHub also supports collaboration through wikis and provides
automation tools like Actions for continuous integration and continuous
deployment (CI/CD).

The concept of "forking a project" is significant in open-source communities.
Traditionally, forking has a negative connotation, as it implies modifying a
project to create a competing version. However, on GitHub, forking is a common
practice that allows users to copy a project and contribute to it without having
direct write access. This encourages collaboration and innovation, as developers
can experiment with changes and propose improvements to the original project.

GitHub's role in the software development ecosystem is crucial, as it provides a
platform for developers to work together, share knowledge, and build upon each
other's work. Its acquisition by Microsoft underscores its value and potential
for growth in the tech industry.

Now, let's explore the impact of GitHub on open-source development and its
community-driven approach.
